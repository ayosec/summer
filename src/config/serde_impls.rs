//! Implementation for serializers and deserializers for custom types.

use super::{Changes, Color, Glob, Regex, SortOrder, SortSpec, Timeout};
use serde::{de, ser, Deserialize, Deserializer, Serialize, Serializer};
use std::borrow::Cow;

// `Color`.
//
// A regular string in Git's color configuration syntax.

impl Serialize for Color {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        ser.serialize_str(self.original.as_str())
    }
}

impl<'de> Deserialize<'de> for Color {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let original = String::deserialize(deserializer)?;
        colorparse::parse(&original)
            .map(|style| Color { original, style })
            .map_err(de::Error::custom)
    }
}

// `Glob`.
//
// A string or a list of strings, stored as a `globset::Glob`.

impl Serialize for Glob {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        self.original.serialize(ser)
    }
}

impl<'de> Deserialize<'de> for Glob {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        #[derive(Deserialize)]
        #[serde(untagged)]
        enum GlobData {
            S(String),
            V(Vec<String>),
        }

        let globs = match GlobData::deserialize(deserializer)? {
            GlobData::S(s) => vec![s],
            GlobData::V(v) => v,
        };

        Glob::new(globs).map_err(de::Error::custom)
    }
}

// `Changes`.
//
// Can be either a duration (like `3 hours`) or `git`.

impl Serialize for Changes {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        match self {
            Changes::Git => ser.serialize_str("git"),
            Changes::Duration(d) => ser.serialize_str(&format!("{} ms", d.as_millis())),
        }
    }
}

impl<'de> Deserialize<'de> for Changes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let value = Cow::<str>::deserialize(deserializer)?;
        if value == "git" {
            Ok(Changes::Git)
        } else {
            humantime::parse_duration(&value)
                .map(Changes::Duration)
                .map_err(de::Error::custom)
        }
    }
}

// `Regex`.
//
// A duration using the syntax from the humantime crate.

impl Serialize for Regex {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        ser.serialize_str(self.0.as_str())
    }
}

impl<'de> Deserialize<'de> for Regex {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let re = Cow::<str>::deserialize(deserializer)?;
        regex::Regex::new(&re).map(Regex).map_err(de::Error::custom)
    }
}

// `SortSpec`.
//
// Sort specification can be either "key" or "key order".

impl Serialize for SortSpec {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        // To reuse the code generated by serde, we serialize a tuple with the
        // values, and then extract the identifiers from the string.

        let yaml = serde_yaml::to_string(&(self.0, self.1)).map_err(ser::Error::custom)?;

        let string: Vec<_> = yaml
            .split_whitespace()
            .filter(|w| w.chars().next().unwrap_or_default().is_alphabetic())
            .collect();

        ser.serialize_str(&string.join(" "))
    }
}

impl<'de> Deserialize<'de> for SortSpec {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let spec = Cow::<str>::deserialize(deserializer)?;
        match memchr::memchr(b' ', spec.as_bytes()) {
            Some(space) => {
                let (key, order) = spec.split_at(space);

                Ok(SortSpec(
                    serde_yaml::from_str(key).map_err(de::Error::custom)?,
                    serde_yaml::from_str(order.trim()).map_err(de::Error::custom)?,
                ))
            }

            None => Ok(SortSpec(
                serde_yaml::from_str(&spec).map_err(de::Error::custom)?,
                SortOrder::Asc,
            )),
        }
    }
}

// `Timeout`.
//
// A duration using the syntax from the humantime crate.

impl Serialize for Timeout {
    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        ser.serialize_str(&format!("{} ms", self.0.as_millis()))
    }
}

impl<'de> Deserialize<'de> for Timeout {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let value = Cow::<str>::deserialize(deserializer)?;
        humantime::parse_duration(&value)
            .map(Timeout)
            .map_err(de::Error::custom)
    }
}
